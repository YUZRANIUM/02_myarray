// INFO ************************************************************************
// FileName : 02_myarray.hsp
// Version  : 0.26.1
// Date     : 2022/12/20
// Author   : YUZRANIUM（ゆずらにうむ）
// Twitter  : https://twitter.com/YUZRANIUM
// GitHub   : https://github.com/YUZRANIUM/02_myarray
// *****************************************************************************
/* Description
 多次元配列をなんやかんやするモジュールです。おまけ付きです

	このモジュールはHSPTV!掲示板の皆様によって支えられております。
	この場を借りて感謝申し上げます。誠に有難うございます。

	***  掲示板情報  ***
	kind    : 宣伝
	date    : 2022/11/26
	person  : Yuzranium
	content : 多次元配列変数を複数行文字列に
********************************************************************************/


/////////////////////////////  ちょびっとつーるず  //////////////////////////////
#ifndef __my_tools__
#define global __my_tools__
#module "mytool"

;===============================================================================
// objprm のハンドル指定版(内部命令)
//
// objhwnd_     : オブジェクトハンドル
// -------------
// obj_prmdata_ : 表示する値(マクロから)
#deffunc local objprh_ int objhwnd_, var obj_prmdata_
	sendmsg objhwnd_, $C, 0, obj_prmdata_
	return
/*--------------------------------------------------------*/
// objprm のハンドル指定版
//
// p1 : オブジェクトハンドル
// p2 : 変数(値の直接指定でも可)
#define global objprh(%1,%2)\
	midlevar_@mytool=%2:\
	objprh_@mytool %1,midlevar_@mytool

;===============================================================================
// 変数名と行数表示
//
// p1      : 表示させたい値
// ---------
// vname   : 変数名 (マクロから)
// linenum : 行  数 (マクロから)
#deffunc local logpri_ var p1, str vname, int lineunm
	logmes "" + strf("/*** %d ***/\n%s = %s\n", lineunm, vname, p1)
	return
/*--------------------------------------------------------*/
// 変数名と行数表示
//
// p1 : 表示させたい値
#define global logpri(%1)\
	midlevar_@mytool=%1:\
	logpri_@mytool midlevar_@mytool,"%1",__line__

#global // mytool
#endif  //__my_tools__
/////////////////////////  ちょびっとつーるず ここまで  //////////////////////////



///////////////////////////  本体は ここから [EOF]まで  /////////////////////////

#ifndef __myarray__
#define global __myarray__

#module "myarray"

#const STRUCTDAT_SIZE 28
#const PRM_STACK      207

	; 内部変数の初期化
	; このファイルの最下部で使用しておりますので特別、呼び出す必要はありません
#deffunc local _myarray_init_
	; 分岐用ラベル
	; *未対応の型, *1次元, *2次元, *3次元, *4次元
	;
	ldim jump_, 5, 6
		; (0, 0) 配列情報表示 * 使用箇所 : ainfo_
		; (0, 1) 配列書き出し * 使用箇所 : priarray_dx
		; (0, 2) 配列連続代入 * 使用箇所 : setarray_
		; (0, 3) 配列生値出力 * 使用箇所 : outarray_
		; (0, 4) 配列生値読込 * 使用箇所 : cnvarray_
		; (0, 5) ラベル型配列 * 使用箇所 : labarray_
	jump_(0, 0) = *notvarinfo@myarray, *D1_aryinfo@myarray, *D2_aryinfo@myarray, *D3_aryinfo@myarray, *D4_aryinfo@myarray
	jump_(0, 1) = *not_varpri@myarray, *priarray_1@myarray, *priarray_2@myarray, *priarray_3@myarray, *priarray_4@myarray
	jump_(0, 2) = *not_varset@myarray, *setarray_1@myarray, *setarray_2@myarray, *setarray_3@myarray, *setarray_4@myarray
	jump_(0, 3) = *not_varout@myarray, *outarray_1@myarray, *outarray_2@myarray, *outarray_3@myarray, *outarray_4@myarray
	jump_(0, 4) = *not_varcnv@myarray, *cnvarray_1@myarray, *cnvarray_2@myarray, *cnvarray_3@myarray, *cnvarray_4@myarray
	jump_(0, 5) = *not_varlab@myarray, *labarray_1@myarray, *labarray_2@myarray, *labarray_3@myarray, *labarray_4@myarray

	; ##########################################################################
	; *** 変数の型名表示 ***
	; * 変数の型名を変更する場合はこちらを編集して下さい
	; ※配列で管理しているのでvartypeで取得する数値と要素数を一致させる必要があります
	; 例）vtype_names(vartype(ary))
	;
	; * 使用箇所: 配列の情報表示 ainfo_    分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
	;
	vtype_names = "", "label", "str", "double", "int", "struct", "comobj"

	; ##########################################################################
	; strf関数用書式文字列
	; *以降の命令・関数内で使用するstrf関数の書式指定文字列は下の変数で管理しています
	; *書式の変更を行いたい場合はこちらを編集して下さい
	sfrmt = ""
	sdim sfrmt, 512, 4, 6

		; ==========================================================================
		; *** 配列の情報表示 ***
		; [ 変数名 ] 型名(1次元要素, 2次元要素, 3次元要素, 4次元要素) L=行数
		; 例）[ ary ] str(5, 4, 3, 2) L=85
		;
		; * 使用箇所: 配列の情報表示 ainfo_   分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
		;
	sfrmt(0, 0) = "[ %s ] %s(%d) L=%s\n"
	sfrmt(1, 0) = "[ %s ] %s(%d, %d) L=%s\n"
	sfrmt(2, 0) = "[ %s ] %s(%d, %d, %d) L=%s\n"
	sfrmt(3, 0) = "[ %s ] %s(%d, %d, %d, %d) L=%s\n"

		; ==========================================================================
		; *** 配列の書き出し ***
		; (1次元要素, 2次元要素, 3次元要素, 4次元要素) = 実際の数値
		; 例）(0, 0, 0, 0) = ABCDE
		; 例）(0, 0, 0, 0) = 12345
		;
		; * 使用箇所: 配列書き出し priarray_dx   分岐ラベル *priarray_1 〜 *priarray_4
		;
	sfrmt(0, 1) = "(%d) = %s\n"
	sfrmt(1, 1) = "(%d, %d) = %s\n"
	sfrmt(2, 1) = "(%d, %d, %d) = %s\n"
	sfrmt(3, 1) = "(%d, %d, %d, %d) = %s\n"

		; ==========================================================================
		; *** 配列の書き出し未対応の型(モジュール型、COMオブジェクト型) ***
		; (1次元要素, 2次元要素, 3次元要素, 4次元要素): varuse [(0x)varptr]
		; 例）(0, 0, 0, 0): 0 [0x12345]
		; 例）(0, 0, 0, 0): 1 [0xabcde]
		;
		; * 使用箇所: 配列書き出し priarray_dx   分岐ラベル *priarray_1 〜 *priarray_4
		;
	sfrmt(0, 2) = "(%d) : %s\t[%d]\n"
	sfrmt(1, 2) = "(%d, %d) : %s\t[%d]\n"
	sfrmt(2, 2) = "(%d, %d, %d) : %s\t[%d]\n"
	sfrmt(3, 2) = "(%d, %d, %d, %d) : %s\t[%d]\n"

		; ==========================================================================
		; *** 配列の情報表示 labarray仕様 *** 行数ダミーの%d
		; dimtype 変数名, 1, 1次元要素, 2次元要素, 3次元要素, 4次元要素
		; 例）dimtype ary, 1, 5, 4, 3, 2
		;
		; * 使用箇所: 配列の情報表示 ainfo_   分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
		;
	sfrmt(0, 3) = "\tdimtype %s, vartype(\"%s\"), %d%s"
	sfrmt(1, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d%s"
	sfrmt(2, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d, %d%s"
	sfrmt(3, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d, %d, %d%s"

		; ======================================================================
		; *** コメント機能 ***
		; ((  配列情報  ))
		; /*------------------------------
		; 何かしらのコメント
		; ------------------------------*/
		; ((  値一覧  ))
		;
		; * 使用箇所: 雑多内部命令 ainfo_
		;
	sfrmt(0, 4) = "/*------------------------------\n%s\n------------------------------*/\n"

		; ======================================================================
		; *** モジュール型変数情報表示用 *** (2022/12/29 現在工事中) ※使用可能
		;
		; STRUCTDAT構造体
	sfrmt(0, 5) = {"
		----------------STRUCTDAT
		index     %d
		subid     %d
		primindex %d
		prmmax    %d
		nameidx   %d
		size      %d
		otindex   %d
	"}
		; PVAL構造体
	sfrmt(1, 5) = {"
		----------------------PVAL
		flag      %d
		mode      %d
		len       %d, %d, %d, %d, %d
		size      %d
		ary ptr   0x%08x (%d)
	"}
		; STRBUF構造体
	sfrmt(2, 5) = {"
		--------------------STRBUF
		Flag      %d
		exFlag    %d
		myblock   %d
		size      %d
		ptr       0x%08x (%d)
		exptr     0x%08x (%d)
		opt       0x%08x (%d)
		--------------------------
	"}
	sfrmt(3, 5) = "%08X\n"

	return


//##############################################################################
	;
	; ラベル名取得用 (このファイルの最下部で使用しておりますので特別、呼び出す必要はありません)
	;
	; 構造体の詳細はhspsdkフォルダのhsp3code.txt,hspdll.txtを参考
	; ※言語仕様としての注意※
	; 1) リリース時にはデバック情報はobj(ax)ファイルに書き込まれない(#cmpopt varname 1は使えない？)
	; ※hsp3_64未対応※
	;
#deffunc local _load_hsphed_

	/*****  hspctx構造体、hsphed構造体の準備  *****/

	mref hspctx, 68                     ; HSPのシステム情報(HSPCTX構造体)
	dupptr hsphed, hspctx(0), 96        ; AXヘッダ情報の詳細(HSPHED構造体)
	dupptr DS, hspctx(3), hsphed(7), 2  ; DS
	dupptr OT, hspctx(5), hsphed(9), 4  ; OT
	dupptr DI, hspctx(4), hsphed(11), 2 ; DI
	; dupptr MI, hspctx(209), hsphed(17)  ; MI モジュールに関する情報があるらしい?
	dupptr FI, hspctx(210), hsphed(15)

	sdim lab_names, 2048    ; ラベル名のリスト用
	dim lab_ofset           ; ラベル名に対応するアドレスポインタ用
	sdim mod_names, 2048    ; モジュール名のリスト
	dim i, 7

	/*****  ラベルリストの作成準備  *****/
	repeat
		if      (peek(DI, i) == 252) {i += 3 : continue}
		else:if (peek(DI, i) == 253) {i += 6 : continue}
		else:if (peek(DI, i) == 254) {i += 6 : continue}
		else:if (peek(DI, i) == 255) {i++    : break}
		else                         {i++    : continue}
	loop
	/*****  ラベルリストの作成  *****/
	repeat , i
		if peek(DI, cnt) = 255 : break
		lab_names(i.2) = namegetc@myarray(lpeek(DI, cnt + 1) & $00FFFFFF)
		lab_ofset(i.2) = ofstgetc@myarray(wpeek(DI, cnt + 4))
		i(2)++
		continue cnt + 6
	loop
	/***  二分木探索用ソート  ***/
	twinsortary lab_ofset, lab_names, 0


	/*****  モジュール･関数関連  *****/
		; --------------------------------------------------
		; index     = SD & $FF ; base LIBDAT index
		; subid     = SD >> 16 ; struct index
		; primindex = SD.1     ; STRUCTPRM index(MINFO)
		; prmmax    = SD.2     ; number of STRUCTPRM
		; nameidx   = SD.3     ; name index  (DS)
		; size      = SD.4     ; struct size (stack)
		; otindex   = SD.5     ; OT index    (Module)
		; --------------------------------------------------
	dim i, 7
	dim MInfo_, 7, int(hsphed.15 / STRUCTDAT_SIZE)

	repeat hsphed(15) / STRUCTDAT_SIZE
		dupptr SD, varptr(FI) + cnt * STRUCTDAT_SIZE, STRUCTDAT_SIZE
		if (SD & $FF) != 253 : continue

		m_primindex(i) = SD.1
		MInfo_(0, i) = (SD & $FF), (SD >> 16), SD.1, SD.2, SD.3, SD.4, SD.5
		mod_names(i) = namegetc@myarray(MInfo_(4, i))
		i++
	loop
	cnvarray_@myarray MInfo, MInfo_, 4, 7, i
	dim MInfo_
	return


;===============================================================================
	; ラベル名･モジュール名文字列取得内部関数
	;
	; p1 : バッファのインデックス
#defcfunc local namegetc int p1
	getstr res, DS, p1
	return res

;-------------------------------------------------------------------------------
	; ラベルポインタ取得
#defcfunc local ofstgetc int p1
	return hspctx(2) + OT(p1) * 2

;===============================================================================


	; PVALのポインタとAPTRを取得
#defcfunc local PVAL_ptr_ var v1, int p1
	dupptr vptr, hspctx(PRM_STACK), 8, 4
	return vptr(p1)

	; 指定した変数のPVALポインタ値を取得
#define ctype PVALptr(%1) PVAL_ptr_@myarray(%1, 0)

	; 指定した(配列)変数のAPTR値を取得
#define ctype getAptr(%1) PVAL_ptr_@myarray(%1, 1)

	; v1で指定した変数に対するPVAL構造体の内容をaryで指定した変数にコピー
#deffunc get_PVAL array ary, var v1
	dim ary, 12
	dupptr PVAL, PVALptr(v1), 48, 4
	memcpy ary, PVAL, 48
	return


;===============================================================================
	; sortgetの関数バージョン
	;
	; p1 : index No.
#defcfunc sortgetc int p1
	sortget sortget_res, p1
	return sortget_res

;-------------------------------------------------------------------------------
	; 一方の配列のソートに合わせて他方もソート
	;
	; ary1 : 主配列(メイン)
	; ary2 : 副配列(ary1に合わせてソートする配列)
	; p1   : 昇降順
#deffunc twinsortary array ary1, array ary2, int p1, local _my_tmp_
	dimtype _my_tmp_, vartype(ary2), length(ary2)
	; 一時保存
	foreach ary2
		_my_tmp_(cnt) = ary2(cnt)
	loop
	; 変数型に合わせて分岐･メインの配列ソート実行
	if      (vartype(ary1) == 4) {sortval ary1, p1}
	else:if (vartype(ary1) == 2) {sortstr ary1, p1}

	foreach ary2
		ary2(cnt) = _my_tmp_(sortgetc(cnt))
	loop
	return


;===============================================================================
	; 二分木探索命令
	;
	; item_    : 探す値
	; srch_lis : 探す場所（1次元配列変数)     ※注意!※ 昇順ソートされている事が前提!!
	; srch_ : 探す場所の配列要素数を受け取る変数
#deffunc bisrch var item_, array srch_lis, array srch_

	dim srch_, 3 : srch_(2) = length(srch_lis) - 1
	; srch_(0) : midle
	; srch_(1) : low
	; srch_(2) : high
	repeat
		srch_.0 = (srch_.1 + srch_.2) / 2
		if      ((srch_.1 <= srch_.2) != 1) {srch_.0 = -1 : break}
		else:if (item_ = srch_lis(srch_.0)) {break}
		else:if (item_ < srch_lis(srch_.0)) {srch_.2 = srch_.0 - 1}
		else                                {srch_.1 = srch_.0 + 1}
	loop
	return


;===============================================================================
	; ラベル名･モジュール名取得関数
	;
	; modlab_var : ラベル型もしくはモジュール型変数
#defcfunc modlabget var modlab_var
	if      vartype(modlab_var) == 1 {
		dupptr clone, varptr(modlab_var), 4
		bisrch clone, lab_ofset, sinfo

		if (sinfo != -1) {return "*" + lab_names(sinfo)}
		else             {return "<null-label>"}
	}
	else:if vartype(modlab_var) == 5 {
		dupptr clone, varptr(modlab_var), 16
		bisrch clone(1), m_primindex, sinfo

		if (sinfo != -1) {return "" + mod_names(sinfo)}
		else             {return "[not-found]"}
	}


//##############################################################################
	;
	; 配列の情報表示 と その他 雑多な処理
	;
	; -変数名文字列の半角スペース除去 (マクロ展開による取得の弊害(?)として原因不明の半角スペースが混入するため)
	; -変数型の真偽値をあらかじめ変数で保持
	; -配列分解処理ループの下準備
	;
	; ary     : 配列変数
	; vname   : 変数名
	; linenum : 行数
	; coment  : コメント
	;
#deffunc local ainfo_ var hyouj, array ary, str vname, var linenum, var coment, int cl

	; 半角スペースのトリミング
	hogestr = vname  :  hogestr = strtrim(hogestr, 3,)

	/***  以降の if-else での型分岐用  ***/
	vtype(0) = (vartype(ary) == 1) | (vartype(ary) == 5)
	repeat 6, 1
		vtype(cnt) = (vartype(ary) == cnt)
	loop

	/*****  配列分解処理ループの下準備  *****/
	; 各次元要素の保持
	all_dim = length(ary), length2(ary), length3(ary), length4(ary)
	; 使用次元の確認
	use_dim = (all_dim(0) != 0) + (all_dim(1) != 0) + (all_dim(2) != 0) + (all_dim(3) != 0)


	if cl == -1 : goto jump_(0, 0) ; setarray, outarrayから呼び出された場合はここで return
	//
	//######################################################


	/*****  priarray, labarrayの出力複数行文字列の冒頭書式の処理  *****/
	; 書式の変更
	; priarrayから呼び出される場合はsfrmt(0, 0) labarrayはsfrmt(0, 3)
	;
	if (cl == 0) {hoge = 0 } else:if (cl == -2) { hoge = 3}

	gosub jump_(use_dim, 0)    ; ラベルジャンプで分岐 (冒頭文字列の記述実行)
	//
	//######################################################


	/*****  labarray専用処理  *****/
	if (linenum == "") {hyouj = strtrim(hyouj, 2,) : strrep hyouj, "\"str\"", "\"label\"" : hyouj += "\n"}

	/*****  コメント･エラーレポート機能の処理  *****/
	if (coment != "") {hyouj += strf(sfrmt(0, 4), coment)}

	return

//-------------------------------  配列情報表示  -------------------------------//
	; priarray用 : sfrmt(n, 0)
	;[ 変数名 ] 型(1次元要素, 2次元要素, 3次元要素, 4次元要素) L=行数
	; labarray用 : sfrmt(n, 3)
	;	dimtype 変数名, vartype("label"), 1次元要素, 2次元要素, 3次元要素, 4次元要素

; jump_(0, 0)
*notvarinfo@myarray
	return

; jump_(1, 0)
*D1_aryinfo@myarray
	hyouj += strf(sfrmt(0, hoge), hogestr, vtype_names(vartype(ary)), length(ary), linenum)
	return

; jump_(2, 0)
*D2_aryinfo@myarray
	hyouj += strf(sfrmt(1, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), linenum)
	return

; jump_(3, 0)
*D3_aryinfo@myarray
	hyouj += strf(sfrmt(2, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), length3(ary), linenum)
	return

; jump_(4, 0)
*D4_aryinfo@myarray
	hyouj += strf(sfrmt(3, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), length3(ary), length4(ary), linenum)
	return


//##############################################################################
	; 動作制御命令
	;
	; d1,d2 : 情報表示、連続代入、書き出し動作の開始次元
	;
#deffunc ctlarray int d1, int d2
	dim ctl_ary, 6
	ctl_ary(0) = d1, d2     ; 各命令の動作開始
	ctl_ary(2) = 0          ; 制御ID == 動作ID
	ctl_ary(3) = ((0 <= d1) & (0 <= d2) & (d1 <= d2))
	ctl_ary(4)++            ; 制御ID (自分(ctrarray_)が呼び出された回数)
	ctl_ary(5) = 0          ; 動作ID (制御される側の命令が呼び出された回数)
	return


//##############################################################################
	;
	; n次元配列の書き出し
	;
	; vname   : 変数名 (マクロから)
	; linenum : 行数   (マクロから)
	; --------------------------------------------
	; hyouj   : 配列変数の中身を受け取る文字列型変数
	; ary     : 配列変数
	; coment  : コメント
	;
#deffunc local priarray_dx str vname, var linenum, var hyouj, array ary, var coment
	dim i, 7
	; 配列情報表示用の内部命令
	ainfo_@myarray hyouj, ary, vname, linenum, coment, 0

	if vtype(6) : goto jump_(0, 0) ; COMオブジェクト型はreturn
	//######################################################

	sum_dim = 1     ; 配列数合計
	repeat 4
		if (all_dim(cnt) == 0)  :  break
		sum_dim *= all_dim(cnt)
	loop

	; 動作ID : 制御IDと動作IDが一致しているか
	ctl_ary(5)++ : ctl_ary(2) = (ctl_ary(4) == ctl_ary(5))
	; ctrarray(動作制御命令)による離脱設定
	if (ctl_ary(2) & ctl_ary(3)) {i(4) = ctl_ary(0) : sum_dim = (ctl_ary(1) - i(4))}

	; 書き出し
	repeat sum_dim
		repeat use_dim
			num_ = i(4)
			repeat cnt
				num_ /= all_dim(cnt)
			loop
			i(cnt) = num_ \ all_dim(cnt)
		loop
		gosub jump_(use_dim, 1)      ; ラベルジャンプで分岐
		i(4)++
	loop

	if vtype(5) {
		dupptr PVAL, PVALptr(ary), 48
		dupptr STRBUF, PVAL(7) - 24, 88
		; STRUCTDAT構造体
		hyouj += strf(sfrmt(0, 5), MInfo(0, sinfo), MInfo(1, sinfo), MInfo(2, sinfo), MInfo(3, sinfo), MInfo(4, sinfo), MInfo(5, sinfo), MInfo(6, sinfo))
		; PVAL構造体
		hyouj += strf(sfrmt(1, 5), PVAL & $FF, PVAL >> 16, PVAL.1, PVAL.2, PVAL.3, PVAL.4, PVAL.5, PVAL.6, PVAL.7, PVAL.7)
		; STRBUF構造体
		hyouj += strf(sfrmt(2, 5), STRBUF & $FF, STRBUF >> 16, STRBUF.1, STRBUF.2, STRBUF.3, STRBUF.3, STRBUF.4, STRBUF.4, STRBUF.5, STRBUF.5)
	}

	hyouj += "\n"      ; 次の配列変数表示のための改行
	return
//-------------------------------  配列書き出し  -------------------------------//

; 未対応の型はこちらへ jump_(0, 1)
*not_varpri@myarray
	return

; 1次元配列 jump_(1, 1)
*priarray_1@myarray
	if (vtype.0) {hyouj += strf(sfrmt(0, 2), i.0, modlabget(ary(i.0)), varptr(ary(i.0)))}
	else:         hyouj += strf(sfrmt(0, 1), i.0, ary(i.0))
	return

; 2次元配列 jump_(2, 1)
*priarray_2@myarray
	if (vtype.0) {hyouj += strf(sfrmt(1, 2), i.0, i.1, modlabget(ary(i.0, i.1)), varptr(ary(i.0, i.1)))}
	else:         hyouj += strf(sfrmt(1, 1), i.0, i.1, ary(i.0, i.1))
	return

; 3次元配列 jump_(3, 1)
*priarray_3@myarray
	if (vtype.0) {hyouj += strf(sfrmt(2, 2), i.0, i.1, i.2, modlabget(ary(i.0, i.1, i.2)), varptr(ary(i.0, i.1, i.2)))}
	else:         hyouj += strf(sfrmt(2, 1), i.0, i.1, i.2, ary(i.0, i.1, i.2))
	return

; 4次元配列 jump_(4, 1)
*priarray_4@myarray
	if (vtype.0) {hyouj += strf(sfrmt(3, 2), i.0, i.1, i.2, i.3, modlabget(ary(i.0, i.1, i.2, i.3)), varptr(ary(i.0, i.1, i.2, i.3)))}
	else:         hyouj += strf(sfrmt(3, 1), i.0, i.1, i.2, i.3, ary(i.0, i.1, i.2, i.3))
	return


//##############################################################################
	;
	; 多次元配列書き出しマクロ
	;
	; %1 : 配列変数の中身を受け取る文字列型変数
	; %2 : 配列変数
	; %3 : コメント
	;
#define global priarray(%1,%2,%3="")\
	midlevar_@myarray=%3:\
	clinevar_@myarray=__line__:\
	priarray_dx@myarray "%2",clinevar_@myarray,%1,%2,midlevar_@myarray


//##############################################################################
	;
	; 配列連続代入内部命令
	;
	; vname   : 変数名（マクロから）
	; linenum : 行数  （マクロから）
	; ----------------------------------
	; ary     : 代入先の配列変数
	; in_val  : 代入値またはそれを格納した変数
	; iflg    : indexフラグ(=0) (0 : OFF, 1 : ON)
	; index   : 増減値
	;
#deffunc local setarray_ str vname, var linenum, array ary, var in_val, int iflg, var index
	dim i, 7
	inpt_buf = ""  :  indexbuf_ = ""   ; ダミー
	ainfo_@myarray inpt_buf, ary, vname, linenum, indexbuf_, -1

	if (vtype(0) | vtype(6)) : goto jump_(0, 2)
	//######################################################

	; 代入値が文字列の場合、インデックス付与のために一旦退避
	if (iflg == 1) & (vtype(2))  :  inpt_buf = in_val  :  indexbuf_ = index

	; 配列数合計
	sum_dim = 1
	repeat 4
		if (all_dim(cnt) == 0)  :  break
		sum_dim *= all_dim(cnt)
	loop

	; 動作ID : 制御IDと動作IDが一致しているか
	ctl_ary(5)++ : ctl_ary(2) = (ctl_ary(4) == ctl_ary(5))
	; ctrarray(動作制御命令)による離脱設定
	if (ctl_ary(2) & ctl_ary(3)) {i(4) = ctl_ary(0) : sum_dim = (ctl_ary(1) - i(4))}

	repeat sum_dim
		repeat use_dim
			num_ = i(4)
			repeat cnt
				num_ /= all_dim(cnt)
			loop
			i(cnt) = num_ \ all_dim(cnt)
		loop
		gosub jump_(use_dim, 2)         ; ラベルジャンプで分岐

		; 文字列に対してインデックスの付与
		if (iflg == 1) & (vtype(2)) {
			in_val = inpt_buf           ; 足される方を元データに上書き
			in_val += "" + indexbuf_    ; インデックスの追加
			indexbuf_ += index          ; インデックスカウントアップ
		}
		else:if (iflg == 1)  :  in_val += index

		i(4)++
	loop
	return
//---------------------------------  配列代入  ---------------------------------//

; 未対応の型はこちらへ jump_(0, 2)
/////////////////////////////  エラーレポートの発行  /////////////////////////////
*not_varset@myarray
	; error_report_ += strf(sfrmt(1, 4), hogestr, linenum)
	return

; 1次元配列 jump_(1, 2)
*setarray_1@myarray
	ary(i(0)) = in_val
	return

; 2次元配列 jump_(2, 2)
*setarray_2@myarray
	ary(i(0), i(1)) = in_val
	return

; 3次元配列 jump_(3, 2)
*setarray_3@myarray
	ary(i(0), i(1), i(2)) = in_val
	return

; 4次元配列 jump_(4, 2)
*setarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = in_val
	return


//##############################################################################
	;
	; 多次元配列連続代入マクロ
	;
	; %1 : 代入先の配列変数
	; %2 : 代入したい値
	; %3 : indexフラグ(=0)(0 : OFF, 1 : ON)
	; %4 : 増減値 (str, double, int)
	;
#define global setarray(%1,%2,%3=0,%4=1)\
	midlevar_@myarray=%2:\
	increase_@myarray=%4:\
	clinevar_@myarray=__line__:\
	setarray_@myarray "%1",clinevar_@myarray,%1,midlevar_@myarray,%3,increase_@myarray


//##############################################################################
	;
	; n次元配列の生値出力
	;
	; hyouj : 配列変数の中身を受け取る文字列型変数
	; ary   : 配列変数
	; iflg  : 機能フラグ (= 0, 1: ラベルモード, 2: 16進数大文字モード)
	;
#deffunc local outarray_ var hyouj, array ary, int iflg
	dim i, 7
	hoge = ""       ; ダミー
	ainfo_@myarray hyouj, ary, "", hoge, hoge, -1
	hoge = "\n", "\n\treturn\n"

	; 配列数合計
	sum_dim = 1
	repeat 4
		if (all_dim(cnt) == 0)  :  break
		sum_dim *= all_dim(cnt)
	loop

	; 動作ID : 制御IDと動作IDが一致しているか
	ctl_ary(5)++ : ctl_ary(2) = (ctl_ary(4) == ctl_ary(5))
	; ctrarray(動作制御命令)による離脱設定
	if (ctl_ary(2) & ctl_ary(3)) {i(4) = ctl_ary(0) : sum_dim = (ctl_ary(1) - i(4))}

	; 書き出し
	repeat sum_dim
		repeat use_dim
			num_ = i(4)
			repeat cnt
				num_ /= all_dim(cnt)
			loop
			i(cnt) = num_ \ all_dim(cnt)
		loop
		gosub jump_(use_dim, 3)         ; ラベルジャンプで分岐
		i(4)++
	loop

	hyouj += "\n"      ; 次の配列変数表示のための改行
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varout@myarray
	return

; 1次元配列 jump_(1, 3)
*outarray_1@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0))}
	else:if vtype(1) {hyouj += "" + modlabget(ary(i.0)) + hoge.1}
	else             {hyouj += "" + ary(i.0) + hoge.iflg}
	return

; 2次元配列 jump_(2, 3)
*outarray_2@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1))}
	else:if vtype(1) {hyouj += "" + modlabget(ary(i.0, i.1)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1) + hoge.iflg}
	return

; 3次元配列 jump_(3, 3)
*outarray_3@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1, i.2))}
	else:if vtype(1) {hyouj += "" + modlabget(ary(i.0, i.1, i.2)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1, i.2) + hoge.iflg}
	return

; 4次元配列 jump_(4, 3)
*outarray_4@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1, i.2, i.3))}
	else:if vtype(1) {hyouj += "" + modlabget(ary(i.0, i.1, i.2, i.3)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1, i.2, i.3) + hoge.iflg}
	return


//##############################################################################
	;
	; n次元配列の値のみを書き出すマクロ
	;
	; hyouj : 配列変数の中身を受け取る文字列型変数
	; ary   : 配列変数
	; iflg  : 機能フラグ (= 0, 1: ラベルモード, 2: 16進数大文字モード)
	;
#define global outarray(%1,%2,%3=0) outarray_@myarray %1,%2,%3



//##############################################################################
	;
	; あらゆるものを多次元配列に変換する
	;
	; ary         : 変数名
	; in_val      : 読み込む複数行文字列若しくは多次元配列変数
	; type        : 変換先の型を表す数値  (= 2) (2:文字列型, 3:実数型, 4:整数型)
	; d1,d2,d3,d4 : 変換後の各配列次元要素数
	;
#deffunc local cnvarray_ array ary, array in_val, int type, int d1, int d2, int d3, int d4
	dim i, 7  :  sdim hogestr, 4096

	; 複数行文字列、多次元配列の判別
	; 要素数が2以上あれば多次元配列とみなしてoutarrayにて複数行文字列化
	if (length(in_val) > 1) {outarray_@myarray hogestr, in_val, 0}
	else                    {hogestr = in_val}
	notesel hogestr

	; 配列の各次元要素数
	if (d1 == 0) {all_dim = length(in_val), length2(in_val), length3(in_val), length4(in_val)}
	else         {all_dim = d1, d2, d3, d4}

	; 配列の初期化 * 型の変換
	if (type == 2) {sdim ary, notesize, all_dim(0), all_dim(1), all_dim(2), all_dim(3)}
	else           { dimtype ary, type, all_dim(0), all_dim(1), all_dim(2), all_dim(3)}

	; 次元の使用状況
	use_dim = (all_dim(0) != 0) + (all_dim(1) != 0) + (all_dim(2) != 0) + (all_dim(3) != 0)

	sum_dim = 1    ; 配列数合計
	repeat 4
		if (all_dim(cnt) == 0) : break
		sum_dim *= all_dim(cnt)
	loop

	dim i, 7
	; 動作ID : 制御IDと動作IDが一致しているか
	ctl_ary(5)++ : ctl_ary(2) = (ctl_ary(4) == ctl_ary(5))
	; ctrarray(動作制御命令)による離脱設定
	if (ctl_ary(2) & ctl_ary(3)) {i(4) = ctl_ary(0) : sum_dim = (ctl_ary(1) - i(4))}

	; 書き出し
	repeat sum_dim
		repeat use_dim
			num_ = i(4)
			repeat cnt
				num_ /= all_dim(cnt)
			loop
			i(cnt) = num_ \ all_dim(cnt)
		loop
		noteget hogeline, i(5)

		if      (type == 2) {hoge =    str(hogeline)}
		else:if (type == 3) {hoge = double(hogeline)}
		else:if (type == 4) {hoge =    int(hogeline)}

		gosub jump_(use_dim, 4)         ; ラベルジャンプで分岐
		i(4)++ : i(5)++
	loop
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varcnv@myarray
	return

; 1次元配列 jump_(1, 4)
*cnvarray_1@myarray
	ary(i(0)) = hoge
	return

; 2次元配列 jump_(2, 4)
*cnvarray_2@myarray
	ary(i(0), i(1)) = hoge
	return

; 3次元配列 jump_(3, 4)
*cnvarray_3@myarray
	ary(i(0), i(1), i(2)) = hoge
	return

; 4次元配列 jump_(4, 4)
*cnvarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = hoge
	return


//##############################################################################
	;
	; あらゆるものを多次元配列に変換する
	;
	; %1          : 変数名（dim系で初期化していなくてもOK）
	; %2          : 読み込む複数行文字列若しくは多次元配列変数
	; %3          : 変換先の型を表す数値 (= 2) (2:文字列型, 3:実数型, 4:整数型)
	; %4,%5,%6,%7 : 変換後の各次元要素数
	;
#define global cnvarray(%1,%2,%3=2,%4=0,%5=0,%6=0,%7=0) cnvarray_@myarray %1,%2,%3,%4,%5,%6,%7


//##############################################################################
	;
	; ラベル型多次元配列生成
	;
	; hyouj  : 書き出し先の複数行文字列型変数
	; ary    : 書き出す文字列型配列変数
	; in_val : 代入値またはそれを格納した変数
	; index  : 増減値
	;
#deffunc local labarray_ str vname, var hyouj, array ary, var in_val, var index, var coment
	dim i, 7
	inpt_buf = ""
	ainfo_@myarray hyouj, ary, vname, inpt_buf, coment, -2
	; インデックス付与のために一旦退避
	inpt_buf = in_val  :  indexbuf_ = index

	sum_dim = 1    ; 配列数合計
	repeat 4
		if (all_dim(cnt) == 0)  :  break
		sum_dim *= all_dim(cnt)
	loop

	; 動作ID : 制御IDと動作IDが一致しているか
	ctl_ary(5)++ : ctl_ary(2) = (ctl_ary(4) == ctl_ary(5))
	; ctrarray(動作制御命令)による離脱設定
	if (ctl_ary(2) & ctl_ary(3)) {i(4) = ctl_ary(0) : sum_dim = (ctl_ary(1) - i(4))}

	repeat sum_dim
		repeat use_dim
			num_ = i(4)
			repeat cnt
				num_ /= all_dim(cnt)
			loop
			i(cnt) = num_ \ all_dim(cnt)
		loop
		gosub jump_(use_dim, 5)         ; ラベルジャンプで分岐

		; 文字列に対してインデックスの付与
		in_val = inpt_buf               ; 足される方を元データに上書き
		in_val += "" + indexbuf_        ; インデックスの追加
		indexbuf_ += index              ; インデックスカウントアップ
		i(4)++
	loop

	hyouj += "\n"
	return
//---------------------------------  配列代入  ---------------------------------//

; 未対応の型はこちらへ jump_(0, 5)
*not_varlab@myarray
	return

; 1次元配列 jump_(1, 5)
*labarray_1@myarray
	ary(i(0)) = in_val
	hyouj += strf("\t%s" + sfrmt(0, 1), hogestr, i(0), in_val)
	return

; 2次元配列 jump_(2, 5)
*labarray_2@myarray
	ary(i(0), i(1)) = in_val
	hyouj += strf("\t%s" + sfrmt(1, 1), hogestr, i(0), i(1), in_val)
	return

; 3次元配列 jump_(3, 5)
*labarray_3@myarray
	ary(i(0), i(1), i(2)) = in_val
	hyouj += strf("\t%s" + sfrmt(2, 1), hogestr, i(0), i(1), i(2), in_val)
	return

; 4次元配列 jump_(4, 5)
*labarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = in_val
	hyouj += strf("\t%s" + sfrmt(3, 1), hogestr, i(0), i(1), i(2), i(3), in_val)
	return


//##############################################################################
	;
	; ラベル型多次元配列生成
	;
	; %1 : 書き出し先の複数行文字列型変数
	; %2 : 書き出す文字列型配列変数
	; %3 : 代入値またはそれを格納した変数
	; %4 : 増減値 (= 1)
	; %5 : コメント
	;
#define global labarray(%1,%2,%3,%4=1,%5="")\
	midlevar_@myarray=%3:\
	increase_@myarray=%4:\
	labcoment@myarray=%5:\
	labarray_@myarray "%2",%1,%2,midlevar_@myarray,increase_@myarray,labcoment@myarray

#global // myarray

	_myarray_init_@myarray    ; モジュール内の管理用変数の初期化です
	_load_hsphed_@myarray     ; ラベル型変数のラベル名取得用

#endif //__myarray__