// INFO ************************************************************************
// FileName : 02_myarray.hsp
// Version  : 0.27.3
// Date     : 2023/01/21
// Author   : YUZRANIUM（ゆずらにうむ）
// Twitter  : https://twitter.com/YUZRANIUM
// GitHub   : https://github.com/YUZRANIUM/02_myarray
// *****************************************************************************
/* Description
 多次元配列をなんやかんやするモジュールです。おまけ付きです

	このモジュールはHSPTV!掲示板の皆様によって支えられております。
	この場を借りて感謝申し上げます。誠に有難うございます。

	***  掲示板情報  ***
	kind    : 宣伝
	date    : 2023/01/16
	person  : Yuzranium
	content : 多次元配列をなんやかんやする

	***  掲示板情報 (過去ログ)  ***
	date    : 2022/11/26
	content : 多次元配列変数を複数行文字列に
********************************************************************************/



/////////////////////////////  ちょびっとつーるず  //////////////////////////////
#ifndef __my_tools__
#define global __my_tools__
#module "mytool"


;===============================================================================
	; objprm のハンドル指定版(内部命令)
	;
	; objhwnd_     : オブジェクトハンドル
	; -------------
	; obj_prmdata_ : 表示する値(マクロから)
#deffunc local objprh_ int objhwnd_, var obj_prmdata_
	sendmsg objhwnd_, $C, 0, obj_prmdata_
	return


;-----------------------------------------------------------
	; objprm のハンドル指定版
	;
	; p1 : オブジェクトハンドル
	; p2 : 変数(値の直接指定でも可)
#define global objprh(%1,%2)\
	midlevar_@mytool=%2:\
	objprh_@mytool %1,midlevar_@mytool



;===============================================================================
	; 変数名と行数表示
	;
	; vname   : 変数名 (マクロから)
	; linenum : 行  数 (マクロから)
	; ----------------------------
	; p1      : 表示させたい値
	; idx_lst : ループ内で使用する際のインデックス(配列の要素数を格納した変数やcntなど)
#deffunc local logpri_ str vname, int lineunm, var p1, array idx_lst
	; 左端の半角スペースのトリミング
	hoge = vname : hoge = strtrim(hoge, 1,)
	repeat 4:   idx_lst(cnt + 4) = strtrim(idx_lst(cnt + 4), 1,)   :loop

	hyouj_ = strf("/*** %d ***/\n%s = %s\n", lineunm, hoge, p1)

	; ループ内でよく用いられる cnt, i++, j++, k++ 等のカウンタを数値に置換
	repeat 4:   strrep hyouj_, str(idx_lst(cnt + 4)), str(idx_lst(cnt))   :loop

	logmes hyouj_
	return


;-----------------------------------------------------------
	; 変数名と行数表示
	;
	; p1 : 表示させたい値
#define global logpri(%1,%2=-1,%3=-1,%4=-1,%5=-1)\
	midlevar_@mytool=%1:\
	indexvar_@mytool(0)=str(%2),str(%3),str(%4),str(%5):\
	indexvar_@mytool(4)="%2","%3","%4","%5":\
	logpri_@mytool "%1",__line__,midlevar_@mytool,indexvar_@mytool

	; indexvar_
	; 0, 1, 2, 3 / 置換する値
	; 4, 5, 6, 7 / 検索される文字列



;===============================================================================
	; logpri の mes バージョン
	;
#deffunc local mesans_ str vname, var hyouj, var v1, array idx_lst

	; 左端の半角スペースのトリミング
	hoge = vname : hoge = strtrim(hoge, 1)
	repeat 4:   idx_lst(cnt + 4) = strtrim(idx_lst(cnt + 4), 1,)   :loop

	hyouj += strf("%s = %s", hoge, str(v1))

	; ループ内でよく用いられる cnt, i++, j++, k++ 等のカウンタを数値に置換
	repeat 4:   strrep hyouj, str(idx_lst(cnt + 4)), str(idx_lst(cnt))   :loop
	hyouj += "\n"
	return


;-----------------------------------------------------------
	; logpri の mes バージョン
	;
#define global mesans(%1,%2,%3=-1,%4=-1,%5=-1,%6=-1)\
	midlevar_@mytool=%2:\
	indexvar_@mytool(0)=str(%3),str(%4),str(%5),str(%6):\
	indexvar_@mytool(4)="%3","%4","%5","%6":\
	mesans_@mytool "%2",%1,midlevar_@mytool,indexvar_@mytool

	; indexvar_
	; 0, 1, 2, 3 / 置換する値
	; 4, 5, 6, 7 / 検索される文字列


#global // mytool
#endif  //__my_tools__
/////////////////////////  ちょびっとつーるず ここまで  //////////////////////////





///////////////////////////  本体は ここから [EOF]まで  /////////////////////////

#ifndef __myarray__
#define global __myarray__

#module "myarray"

#const STRUCTDAT_SIZE 28
#const PRM_STACK      207

	; 内部変数の初期化
	; このファイルの最下部で使用しておりますので特別、呼び出す必要はありません
#deffunc local _myarray_init_
	; 分岐用ラベル
	; *未対応の型, *1次元, *2次元, *3次元, *4次元
	;
	ldim jump_, 5, 8
		; (0, 0) 配列雑多処理 * 使用箇所 : ainfo_
		; (0, 1) 配列情報書出 * 使用箇所 : priarray_dx
		; (0, 2) 配列連続代入 * 使用箇所 : setarray_
		; (0, 3) 配列書き出し * 使用箇所 : outarray_
		; (0, 4) 配列読み込み * 使用箇所 : cnvarray_
		; (0, 5) ラベル型量産 * 使用箇所 : labarray_
		; (0, 6) 配列四則演算 * 使用箇所 : calc_ary_
		; (0, 7) 配列辞書     * 使用箇所 : uniary
	jump_(0, 0) = *notvarinfo@myarray, *D1_aryinfo@myarray, *D2_aryinfo@myarray, *D3_aryinfo@myarray, *D4_aryinfo@myarray
	jump_(0, 1) = *not_varpri@myarray, *priarray_1@myarray, *priarray_2@myarray, *priarray_3@myarray, *priarray_4@myarray
	jump_(0, 2) = *not_varset@myarray, *setarray_1@myarray, *setarray_2@myarray, *setarray_3@myarray, *setarray_4@myarray
	jump_(0, 3) = *not_varout@myarray, *outarray_1@myarray, *outarray_2@myarray, *outarray_3@myarray, *outarray_4@myarray
	jump_(0, 4) = *not_varcnv@myarray, *cnvarray_1@myarray, *cnvarray_2@myarray, *cnvarray_3@myarray, *cnvarray_4@myarray
	jump_(0, 5) = *not_varlab@myarray, *labarray_1@myarray, *labarray_2@myarray, *labarray_3@myarray, *labarray_4@myarray
	jump_(0, 6) = *not_varuni@myarray, *uniarray_1@myarray, *uniarray_2@myarray, *uniarray_3@myarray, *uniarray_4@myarray
	jump_(0, 7) = *not_varcal@myarray, *calc_ary_1@myarray, *calc_ary_2@myarray, *calc_ary_3@myarray, *calc_ary_4@myarray

	; ##########################################################################
	; *** 変数の型名表示 ***
	; * 変数の型名を変更する場合はこちらを編集して下さい
	; ※配列で管理しているのでvartypeで取得する数値と要素数を一致させる必要があります
	; 例）vtype_names(vartype(ary))
	;
	; * 使用箇所: 配列の情報表示 ainfo_    分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
	;
	vtype_names = "", "label", "str", "double", "int", "struct", "comobj"

	; ##########################################################################
	; strf関数用書式文字列
	; *以降の命令・関数内で使用するstrf関数の書式指定文字列は下の変数で管理しています
	; *書式の変更を行いたい場合はこちらを編集して下さい
	sfrmt = ""
	sdim sfrmt, 512, 4, 6

		; ==========================================================================
		; *** 配列の情報表示 ***
		; [ 変数名 ] 型名(1次元要素, 2次元要素, 3次元要素, 4次元要素) L=行数
		; 例）[ ary ] str(5, 4, 3, 2) L=85
		;
		; * 使用箇所: 配列の情報表示 ainfo_   分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
		;
	sfrmt(0, 0) = "[ %s ] %s(%d) L=%s\n"
	sfrmt(1, 0) = "[ %s ] %s(%d, %d) L=%s\n"
	sfrmt(2, 0) = "[ %s ] %s(%d, %d, %d) L=%s\n"
	sfrmt(3, 0) = "[ %s ] %s(%d, %d, %d, %d) L=%s\n"

		; ==========================================================================
		; *** 配列の書き出し ***
		; (1次元要素, 2次元要素, 3次元要素, 4次元要素) = 実際の数値
		; 例）(0, 0, 0, 0) = ABCDE
		; 例）(0, 0, 0, 0) = 12345
		;
		; * 使用箇所: 配列書き出し priarray_dx   分岐ラベル *priarray_1 〜 *priarray_4
		;
	sfrmt(0, 1) = "(%d) = %s\n"
	sfrmt(1, 1) = "(%d, %d) = %s\n"
	sfrmt(2, 1) = "(%d, %d, %d) = %s\n"
	sfrmt(3, 1) = "(%d, %d, %d, %d) = %s\n"

		; ==========================================================================
		; *** 配列の書き出し未対応の型(モジュール型、COMオブジェクト型) ***
		; (1次元要素, 2次元要素, 3次元要素, 4次元要素): varuse [(0x)varptr]
		; 例）(0, 0, 0, 0): 0 [0x12345]
		; 例）(0, 0, 0, 0): 1 [0xabcde]
		;
		; * 使用箇所: 配列書き出し priarray_dx   分岐ラベル *priarray_1 〜 *priarray_4
		;
	sfrmt(0, 2) = "(%d) = %s\t[%d]\n"
	sfrmt(1, 2) = "(%d, %d) = %s\t[%d]\n"
	sfrmt(2, 2) = "(%d, %d, %d) = %s\t[%d]\n"
	sfrmt(3, 2) = "(%d, %d, %d, %d) = %s\t[%d]\n"

		; ==========================================================================
		; *** 配列の情報表示 labarray仕様 *** 行数ダミーの%d
		; dimtype 変数名, 1, 1次元要素, 2次元要素, 3次元要素, 4次元要素
		; 例）dimtype ary, 1, 5, 4, 3, 2
		;
		; * 使用箇所: 配列の情報表示 ainfo_   分岐ラベル *D1_aryinfo 〜 *D4_aryinfo
		;
	sfrmt(0, 3) = "\tdimtype %s, vartype(\"%s\"), %d%s"
	sfrmt(1, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d%s"
	sfrmt(2, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d, %d%s"
	sfrmt(3, 3) = "\tdimtype %s, vartype(\"%s\"), %d, %d, %d, %d%s"

		; ======================================================================
		; *** コメント機能 ***
		; ((  配列情報  ))
		; /*------------------------------
		; 何かしらのコメント
		; ------------------------------*/
		; ((  値一覧  ))
		;
		; * 使用箇所: 雑多内部命令 ainfo_
		;
	sfrmt(0, 4) = "/*------------------------------\n%s\n------------------------------*/\n"

		; ======================================================================
		; *** モジュール型変数情報表示用 *** (2023/01/15 現在工事中) ※使用可能
		;
		; STRUCTDAT構造体
		; --------------------------------------------------
		; index     = SD & $FF ; base LIBDAT index
		; subid     = SD >> 16 ; struct index
		; primindex = SD.1     ; STRUCTPRM index(MINFO)
		; prmmax    = SD.2     ; number of STRUCTPRM
		; nameidx   = SD.3     ; name index  (DS)
		; size      = SD.4     ; struct size (stack)
		; otindex   = SD.5     ; OT index    (Module)
		; --------------------------------------------------
	sfrmt(0, 5) = {"
		----------------STRUCTDAT
		index     %d
		subid     %d
		primindex %d
		prmmax    %d
		nameidx   %d
		size      %d
		otindex   %d
	"}
		; PVAL構造体
	sfrmt(1, 5) = {"
		----------------------PVAL
		flag      %d
		mode      %d
		len       %d, %d, %d, %d, %d
		size      %d
		ary ptr   0x%08x (%d)
	"}
		; STRBUF構造体
	sfrmt(2, 5) = {"
		--------------------STRBUF
		Flag      %d
		exFlag    %d
		myblock   %d
		size      %d
		ptr       0x%08x (%d)
		exptr     0x%08x (%d)
		opt       0x%08x (%d)
		--------------------------
	"}
	sfrmt(3, 5) = "%08X\n"

	; ##########################################################################
	; ラベルリスト作成の際、除外したいラベルに含まれている文字列を登録する
	; こちらに登録した文字列が含まれているラベル名はアドレスポインタ共々除外されます。
	;
	excld_list = "_exit", "_boot", "@"

	; ##########################################################################
	; 動作制御配列
	; ------------------------------------------------------
	; ctl_ary(0)  : 複数制御フラグ
	;
	; ctl_ary(1)  : 対象となる動作を開始する 配列のオフセット値
	; ctl_ary(2)  : 対象となる動作を終了する       //
	;
	; ctl_ary(3)  : 単体制御フラグ
	; ctl_ary(4)  : 除外フラグ
	;
	; ctl_ary(5)  : 真偽値 (オフセット値: (0 <= 開始値) & (開始値 <= 終了値) )
	; ctl_ary(6)  : 真偽値 (複数制御あり & 除外    あり & 制御コア1回目の呼び出し) | (制御なし)
	; ctl_ary(7)  : 真偽値 (複数制御あり & 除外    あり & 制御コア2回目の呼び出し)
	; ctl_ary(8)  : 真偽値 (複数制御なし & 単体制御あり & 制御コア2回目の呼び出し)
	;
	; ctl_ary(9)  : ctl_ary(1)
	; ctl_ary(10) : 配列の長さ - ctl_ary(1)
	; ------------------------------------------------------
	ctl_ary = 0 : dim ctl_ary, 11

	; ##########################################################################
	; 配列情報
	;-------------------------------------------------------
	; ary_inf(0) : length()  (1次元要素数) (旧 : all_dim)
	; ary_inf(1) : length2() (2次元要素数)
	; ary_inf(2) : length3() (3次元要素数)
	; ary_inf(3) : length4() (4次元要素数)
	;
	; ary_inf(4) : 使用次元数 (1, 2, 3, 4) (旧 : use_dim)
	; ary_inf(5) : 配列の長さ              (旧 : sum_dim)
	;
	; ary_inf(6) : 配列の現在位置          (旧 : num_)
	;-------------------------------------------------------
	ary_inf = 0

	; ##########################################################################
	; 配列演算継続フラグ
	;
	calc_add_flag = 0 : dim calc_add_flag


;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;					HSPCTX･HSPHED 構造体
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	; 構造体の詳細はhspsdkフォルダのhsp3code.txt,hspdll.txtを参考
	; ※言語仕様としての注意※
	; 1) リリース時にはデバック情報はobj(ax)ファイルに書き込まれない(#cmpopt varname 1は使えない？)
	; ※hsp3_64未対応※

	/*****  hspctx構造体、hsphed構造体の準備  *****/

	mref hspctx, 68                     ; HSPのシステム情報(HSPCTX構造体)
	dupptr hsphed, hspctx(0), 96        ; AXヘッダ情報の詳細(HSPHED構造体)
	dupptr DS, hspctx(3), hsphed(7), 2  ; DS
	dupptr OT, hspctx(5), hsphed(9), 4  ; OT
	dupptr DI, hspctx(4), hsphed(11), 2 ; DI
	; dupptr MI, hspctx(209), hsphed(17)  ; MI モジュールに関する情報があるらしい?
	dupptr FI, hspctx(210), hsphed(15)

	sdim lab_names, 2048    ; ラベル名のリスト用
	sdim mod_names, 2048    ; モジュール名のリスト
	dim lab_ofset           ; ラベル名に対応するアドレスポインタ用

						;===================================
						; ラベル 関連
						;===================================

	/*****  ラベルリストの作成準備  *****/
	dim i, 7
	repeat
		if      (peek(DI, i) == 252) {i += 3 : continue}
		else:if (peek(DI, i) == 253) {i += 6 : continue}
		else:if (peek(DI, i) == 254) {i += 6 : continue}
		else:if (peek(DI, i) == 255) {i++    : break}
		else                         {i++    : continue}
	loop

	/*****  ラベルリストの作成  *****/
	sdim hoge, 64
	repeat , i
		if peek(DI, cnt) = 255 : break
		hoge = namegetc@myarray(lpeek(DI, cnt + 1) & $00FFFFFF)

		; 除外リストに登録されている文字列と部分一致した場合はスキップ
		if srch_listc_@myarray(hoge, excld_list) : continue cnt + 6

		lab_names(i.2) = hoge
		lab_ofset(i.2) = ofstgetc@myarray(wpeek(DI, cnt + 4))
		i(2)++
		continue cnt + 6
	loop

	/***  二分木探索用ソート  ***/
	twinsortary lab_ofset, lab_names, 0

						;===================================
						; モジュール 関連
						;===================================

	/*****  モジュール･関数関連 (2023/01/15 現在工事中) ※使用可能 *****/
	dim i, 7
	dim midlevar_, 7, int(hsphed.15 / STRUCTDAT_SIZE)

	repeat hsphed(15) / STRUCTDAT_SIZE
		dupptr SD, varptr(FI) + cnt * STRUCTDAT_SIZE, STRUCTDAT_SIZE
		if (SD & $FF) != 253 : continue

		m_primindex(i) = SD.1
		midlevar_(0, i) = (SD & $FF), (SD >> 16), SD.1, SD.2, SD.3, SD.4, SD.5
		mod_names(i) = namegetc@myarray(midlevar_(4, i))
		i++
	loop
	cnvarray_@myarray MInfo, midlevar_, 4, 7, i, 0, 0
	midlevar_ = 0

	return    // _myarray_init_





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;					ポインタ関連
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

						;===================================
						; ラベル名、モジュール名取得関連
						;===================================

	; ラベル名･モジュール名文字列取得
	;
	; p1 : バッファのインデックス
#defcfunc local namegetc int p1
	getstr res, DS, p1
	return res

	; ラベルポインタ取得
#defcfunc local ofstgetc int p1
	return hspctx(2) + OT(p1) * 2

						;===================================
						; PVAL, APTR 関連
						;===================================

	; PVALのポインタとAPTRを取得
#defcfunc local PVAL_ptrc_ var v1, int p1
	dupptr vptr, hspctx(PRM_STACK), 8, 4
	return vptr(p1)

	; 指定した変数のPVALポインタ値を取得
#define ctype PVALptrc(%1) PVAL_ptrc_@myarray(%1, 0)

	; 指定した(配列)変数のAPTR値を取得
#define ctype getAptrc(%1) PVAL_ptrc_@myarray(%1, 1)

	; v1で指定した変数に対するPVAL構造体の内容をaryで指定した変数にコピー
#deffunc get_PVAL array ary, var v1
	dim ary, 12
	dupptr PVAL, PVALptrc(v1), 48, 4
	memcpy ary, PVAL, 48
	return





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;					検索関連
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


						;===================================
						; ソート 関連
						;===================================


	; sortgetの関数バージョン
	;
	; p1 : index No.
#defcfunc sortgetc int p1
	sortget sortget_res, p1
	return sortget_res


	; 一方の配列のソートに合わせて他方もソート
	;
	; ary1 : 主配列(メイン)
	; ary2 : 副配列(ary1に合わせてソートする配列)
	; p1   : 昇降順
#deffunc twinsortary array ary1, array ary2, int p1, local _my_tmp_
	dimtype _my_tmp_, vartype(ary2), length(ary2)
	; 一時保存
	foreach ary2:    _my_tmp_(cnt) = ary2(cnt)    :loop

	; 変数型に合わせて分岐･メインの配列ソート実行
	if      (vartype(ary1) == 4) {sortval ary1, p1}
	else:if (vartype(ary1) == 2) {sortstr ary1, p1}

	foreach ary2:    ary2(cnt) = _my_tmp_(sortgetc(cnt))    :loop
	return



						;===================================
						; 検索
						;===================================


	; 文字列リストとの単純検索
#defcfunc local srch_listc_ var v1, array ary, local found_
	found_ = 0
	repeat length(ary)
		if (instr(v1, 0, ary.cnt) != -1) {found_ = 1 : break}
	loop
	return found_


	; 二分木探索命令
	;
	; item_    : 探す値
	; srch_lis : 探す場所（1次元配列変数) ※注意!※ 昇順ソートされている事が前提!!
	; srch_    : 探す場所の配列要素数を受け取る変数
#deffunc bisrch var item_, array srch_lis, array srch_

	dim srch_, 3 : srch_(2) = length(srch_lis) - 1
	; srch_(0) : midle
	; srch_(1) : low
	; srch_(2) : high
	repeat
		srch_.0 = (srch_.1 + srch_.2) / 2
		if      ((srch_.1 <= srch_.2) != 1) {srch_.0 = -1 : break}
		else:if (item_ = srch_lis(srch_.0)) {break}
		else:if (item_ < srch_lis(srch_.0)) {srch_.2 = srch_.0 - 1}
		else                                {srch_.1 = srch_.0 + 1}
	loop
	return


	; ラベル名･モジュール名取得関数
	;
	; modlab_var : ラベル型もしくはモジュール型変数
	;
#defcfunc modlabgetc var modlab_var
	if      vartype(modlab_var) == 1 {
		dupptr clone, varptr(modlab_var), 4
		bisrch clone, lab_ofset, sinfo

		if (sinfo != -1) {return "*" + lab_names(sinfo)}
		else             {return "<null-label>"}
	}
	else:if vartype(modlab_var) == 5 {
		dupptr clone, varptr(modlab_var), 16
		bisrch clone(1), m_primindex, sinfo

		if (sinfo != -1) {return "" + mod_names(sinfo)}
		else             {return "[not-found]"}
	}




;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;					多次元配列の下処理関連
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; モジュール内で多次元配列を扱うための準備
	;-------------------------------------------------------
	; ary_inf(0) : length()  (1次元要素数) (旧 : all_dim)
	; ary_inf(1) : length2() (2次元要素数)
	; ary_inf(2) : length3() (3次元要素数)
	; ary_inf(3) : length4() (4次元要素数)
	;
	; ary_inf(4) : 使用次元数 (1, 2, 3, 4) (旧 : use_dim)
	; ary_inf(5) : 配列の長さ              (旧 : sum_dim)
	;
	; ary_inf(6) : 配列の現在位置          (旧 : num_)
	;
#deffunc local dim_info_ array ary, array ary_inf_
	dim ary_inf_, 7
	; 配列の各次元要素数
	ary_inf_(0) = length(ary), length2(ary), length3(ary), length4(ary)
	; 使用次元の確認
	ary_inf_(4) = (ary_inf_(0) != 0) + (ary_inf_(1) != 0) + (ary_inf_(2) != 0) + (ary_inf_(3) != 0)
	; 配列合計数
	ary_inf_(5) = 1
	repeat ary_inf_(4):   ary_inf_(5) *= ary_inf_(cnt)   :loop
	return


	; if-else での型分岐用
	;
#deffunc local typ_info_ array ary, array vtype_
	; 変数の型による分岐
	vtype_(0) = (vartype(ary) == 1) | (vartype(ary) == 5)
	repeat 6, 1:   vtype_(cnt) = (vartype(ary) == cnt)   :loop
	return


						;===================================
						; 配列の要素･オフセット値
						;===================================

	; 配列の各次元要素からオフセット値 (1次元化要素数) へ
	;
#defcfunc local dim_num_linec_ array ary_inf_, int d1, int d2, int d3, int d4
	return (d1 + (ary_inf_.0 * d2) + (ary_inf_.0 * ary_inf_.1 * d3) + (ary_inf_.0 * ary_inf_.1 * ary_inf_.2 * d4))


	; 配列のオフセット値 (1次元化要素数) から各次元要素へ
	;
#deffunc local dim_line_num_ array ary_inf_, array i_, int dim_ofset
	repeat ary_inf_(4)
		ary_inf_(6) = dim_ofset
		repeat cnt
			ary_inf_(6) /= ary_inf_(cnt)
		loop
		i_(cnt) = ary_inf_(6) \ ary_inf_(cnt)
	loop
	return


	; 配列のオフセット値から各次元要素を返す
	;
	; ary       : 多次元配列変数
	; i_        : 次元要素数を受け取る変数
	; dim_ofset : aryのオフセット値 (1次元化要素数)
	;
#deffunc linedim array ary, array i_, int dim_ofset
	dim_info_@myarray ary, ary_inf
	if ary_inf(5) < dim_ofset : return 0

	dim i_, 4
	dim_line_num_@myarray ary_inf, i_, dim_ofset
	return


	; 配列の各次元要素から配列のオフセット値 (1次元化要素数) を返す
	;
	; ary         : 多次元配列変数
	; d1,d2,d3,d4 : 各次元要素数
	;
#defcfunc dimlinec array ary, int d1, int d2, int d3, int d4

	dim_info_@myarray ary, ary_inf

	/*****  条件分岐用  *****/
	dim prm_ch, 5 : prm_ch = d1, d2, d3, d4

	repeat 4
		if      (prm_ch.cnt == 0) {continue}
		else:if (prm_ch.cnt <  0) | (ary_inf.cnt <= prm_ch.cnt) {prm_ch.4 = 1}
	loop
	if prm_ch(4) == 1 : return 0        ; 各次元要素数より指定値が大きい または 0より小さい

	dim prm_ch, 5
	prm_ch(0) = (d1 == 0) & (d2 == 0) & (d3 == 0) & (d4 == 0)
	prm_ch(1) = (d1 <= ary_inf.0) & (d2 <= ary_inf.1) & (d3 <= ary_inf.2) & (d4 <= ary_inf.3)

	; prm_ch(2) 配列の "長さ" を返す
	; prm_ch(3) 配列の "オフセット値" を返す
	if      prm_ch(0) {return ary_inf(5)}
	else:if prm_ch(1) {return dim_num_linec_@myarray(ary_inf, d1, d2, d3, d4)}
	else              {return 0}





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                  辞書関連 2023/01/22 試作中
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	; 文字列をアスキーコードに変換
	;
#deffunc local str_to_ascii_code array ary1, var str_v1, int notesize_p1_
	repeat notesize_p1_:   ary1(cnt + 1) = peek(str_v1, cnt)   :loop
	return

	; アスキーコードから文字列に復元
	;
#deffunc local ascii_code_to_str array get_ary_, array ary, int notesize_p1_
	repeat notesize_p1_:   getstr get_ary_(cnt), ary, 0   :loop
	return


	; 辞書名情報
	; ------------------------------------------------------
	; dict_v(0)   : 辞書名の文字数
	; dict_v(1〜) : 以降辞書名のアスキーコードが1文字ずつ保管
	;
	; 辞書情報
	; ------------------------------------------------------
	; dict_inf(0)  : 辞書名の文字数
	;
	;
	; ------------------------------------------------------



	; 辞書の新規作成
	;
	; dict_v    : 変数名
	; dict_name : 辞書の名前
	;
#deffunc dictinit array dict_v, str dict_name

	sdim hogestr : hogestr = dict_name
	notesel hogestr

	; 辞書情報
	dim dict_v, notesize + 1
	dict_v(0) = notesize

	; 文字列の数値化 (アスキーコードとして保持)
	str_to_ascii_code dict_v, hogestr, notesize

	return


#deffunc dictadd array dict_v, str vname, array ary1


	return


#defcfunc dict

	return














;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;					配列処理動作制御関連
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; ctl_ary : 配列制御変数
	; ------------------------------------------------------
	; ctl_ary(0)  : 複数制御フラグ
	;
	; ctl_ary(1)  : 対象となる動作を開始する 配列のオフセット値
	; ctl_ary(2)  : 対象となる動作を終了する       //
	;
	; ctl_ary(3)  : 単体制御フラグ
	; ctl_ary(4)  : 除外フラグ
	;
	; ctl_ary(5)  : 真偽値 (オフセット値: (0 <= 開始値) & (開始値 <= 終了値) )
	; ctl_ary(6)  : 真偽値 (複数制御あり & 除外    あり & 制御コア1回目の呼び出し) | (制御なし)
	; ctl_ary(7)  : 真偽値 (複数制御あり & 除外    あり & 制御コア2回目の呼び出し)
	; ctl_ary(8)  : 真偽値 (複数制御なし & 単体制御あり & 制御コア2回目の呼び出し)
	;
	; ctl_ary(9)  : ctl_ary(1)
	; ctl_ary(10) : 配列の長さ - ctl_ary(1)
	; ------------------------------------------------------

	; 複数制御開始命令
	;
#deffunc ctlarray_start
	dim ctl_ary, 11 : ctl_ary(0) = 1  ; 複数制御フラグ
	return


	; 動作制御命令
	;
	; ctl_strat_ : 動作を開始する 配列のオフセット値 (1次元化要素数)
	; ctl_end_   : 動作を終了する 配列のオフセット値 (1次元化要素数)
	;
#deffunc ctlarray int ctl_start_, int ctl_end_

	; 複数制御フラグがOFF で呼び出された -> 単体制御ってこと〜!?
	if (ctl_ary(0) == 0) {dim ctl_ary, 11 : ctl_ary(3) = 1}

	ctl_ary(1) = ctl_start_, (ctl_end_ + 1 - ctl_start_)
	ctl_ary(5) = (0 <= ctl_start_) & (ctl_start_ <= ctl_end_)
	return


	; 動作除外命令
	;
#deffunc ctlexcld
	if (ctl_ary(0) == 1) {ctl_ary(4) = 1} ; 動作の除外フラグを立てる
	return


	; 内部動作制御コア
	;
	; p1 : 開始値と終了値の2回呼び出すことになるための識別フラグ P1 = 1 が単体制御終了の合図になる
	; v1 : 制御フラグが立っていない場合は制御値に置き換えずにそのまま返すためのもの
	;
#defcfunc local ctlarray_core_ int p1, var v1

	/*****  条件の整理  *****/
	ctl_ary(6) = (ctl_ary(0) == 1) & (ctl_ary(4) == 1) & (p1 == 0) | (ctl_ary(0) == 0) & (ctl_ary(3) == 0)
	ctl_ary(7) = (ctl_ary(0) == 1) & (ctl_ary(4) == 1) & (p1 == 1)
	ctl_ary(8) = (ctl_ary(0) == 0) & (ctl_ary(3) == 1) & (p1 == 1)

	/*****  制御フラグの操作  *****/
	if      ctl_ary(6) {                 return v1} ; 制御されていない or 除外 の場合は何もせずにそのまま返す
	else:if ctl_ary(7) {ctl_ary(4) = 0 : return v1} ; 複数制御+除外指定かつ最後の呼び出しは除外フラグを下ろす
	else:if ctl_ary(8) {ctl_ary(3) = 0            } ; 単体制御の終了合図があれば単体制御のフラグを下ろす

	ctl_ary(9) = ctl_ary(1), (v1 - ctl_ary(1))

	/*****  制御値の置き換え操作  *****/
	if ctl_ary(5) {return limit(limit(ctl_ary(p1 + 1), 0, ctl_ary(p1 + 9)), 0)} else {return 0}


	; 動作制御終了
	;
#deffunc ctlarray_end
	dim ctl_ary, 11
	return





//##############################################################################
	; 配列の情報表示 と その他 雑多な処理
	;
	; ary     : 配列変数
	; vname   : 変数名
	; linenum : 行数
	; coment  : コメント
	;
#deffunc local ainfo_ var hyouj, array ary, str vname, var linenum, var coment, int cl, local header

	hogestr = vname : hogestr = strtrim(hogestr, 3,)        ; 半角スペースのトリミング
	dim vtype, 7    : typ_info_@myarray ary, vtype          ; 以降の if-else での型分岐用
	dim ary_inf, 7  : dim_info_@myarray ary, ary_inf        ; 配列分解処理の下準備

	; setarray, outarrayから呼び出された場合はここで return
	if cl == -1 : goto jump_(0, 0)
	;___________________________________ ここから下は priarray と labarray のみ


	/*****  出力文字列の冒頭処理  *****/

	; 書式の変更 priarrayはsfrmt(0, 0) labarrayはsfrmt(0, 3)
	if (cl == 0) {hoge = 0} else:if (cl == -2) {hoge = 3}

	gosub jump_(ary_inf(4), 0)    ; (冒頭文字列の記述実行)
	;___________________________________

	/*****  labarray専用処理  *****/
	if (linenum == "") {header = strtrim(header, 2,)  :  strrep header, "\"str\"", "\"label\""  :  header += "\n"}
	/*****  コメント機能の処理  *****/
	if (coment != "")  {header += strf(sfrmt(0, 4), coment)}

	hyouj += header
	return
//-------------------------------  配列情報表示  -------------------------------//

; jump_(0, 0)
*notvarinfo@myarray
	return

; jump_(1, 0)
*D1_aryinfo@myarray
	header = strf(sfrmt(0, hoge), hogestr, vtype_names(vartype(ary)), length(ary), linenum)
	return

; jump_(2, 0)
*D2_aryinfo@myarray
	header = strf(sfrmt(1, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), linenum)
	return

; jump_(3, 0)
*D3_aryinfo@myarray
	header = strf(sfrmt(2, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), length3(ary), linenum)
	return

; jump_(4, 0)
*D4_aryinfo@myarray
	header = strf(sfrmt(3, hoge), hogestr, vtype_names(vartype(ary)), length(ary), length2(ary), length3(ary), length4(ary), linenum)
	return





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   priarray (配列の情報書き出し)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; vname   : 変数名 (マクロから)
	; linenum : 行数   (マクロから)
	; --------------------------------------------
	; hyouj   : 配列変数の中身を受け取る文字列型変数
	; ary     : 配列変数
	; coment  : コメント
	;
#deffunc local priarray_dx str vname, var linenum, var hyouj, array ary, var coment
	; 配列情報表示用の内部命令
	ainfo_@myarray hyouj, ary, vname, linenum, coment, 0

	if vtype(6) : goto jump_(0, 0) ; COMオブジェクト型はreturn
	;_______________________________________________________

	dim i, 7
	; ctrarray(動作制御命令)による離脱設定
	i(4)       = ctlarray_core_@myarray(0, i(4))
	ary_inf(5) = ctlarray_core_@myarray(1, ary_inf(5))

	; 書き出し
	repeat ary_inf(5)
		dim_line_num_@myarray ary_inf, i, i(4)
		gosub jump_(ary_inf(4), 1)         ; ラベルジャンプで分岐
		i(4)++
	loop

	if vtype(5) & ary_inf(5) {
		dupptr PVAL, PVALptrc(ary), 48
		dupptr STRBUF, PVAL(7) - 24, 88
		; STRUCTDAT構造体
		hyouj += strf(sfrmt(0, 5), MInfo(0, sinfo), MInfo(1, sinfo), MInfo(2, sinfo), MInfo(3, sinfo), MInfo(4, sinfo), MInfo(5, sinfo), MInfo(6, sinfo))
		; PVAL構造体
		hyouj += strf(sfrmt(1, 5), PVAL & $FF, PVAL >> 16, PVAL.1, PVAL.2, PVAL.3, PVAL.4, PVAL.5, PVAL.6, PVAL.7, PVAL.7)
		; STRBUF構造体
		hyouj += strf(sfrmt(2, 5), STRBUF & $FF, STRBUF >> 16, STRBUF.1, STRBUF.2, STRBUF.3, STRBUF.3, STRBUF.4, STRBUF.4, STRBUF.5, STRBUF.5)
	}

	hyouj += "\n"      ; 次の配列変数表示のための改行
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varpri@myarray
	return

; 1次元配列 jump_(1, 1)
*priarray_1@myarray
	if (vtype.0) {hyouj += strf(sfrmt(0, 2), i.0, modlabgetc(ary(i.0)), varptr(ary(i.0)))}
	else:         hyouj += strf(sfrmt(0, 1), i.0, ary(i.0))
	return

; 2次元配列 jump_(2, 1)
*priarray_2@myarray
	if (vtype.0) {hyouj += strf(sfrmt(1, 2), i.0, i.1, modlabgetc(ary(i.0, i.1)), varptr(ary(i.0, i.1)))}
	else:         hyouj += strf(sfrmt(1, 1), i.0, i.1, ary(i.0, i.1))
	return

; 3次元配列 jump_(3, 1)
*priarray_3@myarray
	if (vtype.0) {hyouj += strf(sfrmt(2, 2), i.0, i.1, i.2, modlabgetc(ary(i.0, i.1, i.2)), varptr(ary(i.0, i.1, i.2)))}
	else:         hyouj += strf(sfrmt(2, 1), i.0, i.1, i.2, ary(i.0, i.1, i.2))
	return

; 4次元配列 jump_(4, 1)
*priarray_4@myarray
	if (vtype.0) {hyouj += strf(sfrmt(3, 2), i.0, i.1, i.2, i.3, modlabgetc(ary(i.0, i.1, i.2, i.3)), varptr(ary(i.0, i.1, i.2, i.3)))}
	else:         hyouj += strf(sfrmt(3, 1), i.0, i.1, i.2, i.3, ary(i.0, i.1, i.2, i.3))
	return


//##############################################################################
	; 多次元配列書き出しマクロ
	;
	; %1 : 配列変数の中身を受け取る文字列型変数
	; %2 : 配列変数
	; %3 : コメント
	;
#define global priarray(%1,%2,%3="")\
	midlevar_@myarray=%3:\
	clinevar_@myarray=__line__:\
	priarray_dx@myarray "%2",clinevar_@myarray,%1,%2,midlevar_@myarray





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   setarray (配列の連続代入)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; ary     : 代入先の配列変数
	; in_val  : 代入値またはそれを格納した変数
	; iflg    : indexフラグ(= 0, 0:OFF, 1:ON)
	; index   : 増減値
	;
#deffunc local setarray_ array ary, var in_val, int iflg, var index

	inpt_buf = ""  :  indexbuf_ = ""   ; ダミー
	ainfo_@myarray inpt_buf, ary, "", inpt_buf, indexbuf_, -1

	if (vtype(0) | vtype(6)) : goto jump_(0, 2)
	;_______________________________________________________

	; 代入値が文字列の場合、インデックス付与のために一旦退避
	if (iflg == 1) & (vtype(2))  :  inpt_buf = in_val  :  indexbuf_ = index

	dim i, 7
	; ctrarray(動作制御命令)による離脱設定
	i(4)       = ctlarray_core_@myarray(0, i(4))
	ary_inf(5) = ctlarray_core_@myarray(1, ary_inf(5))

	repeat ary_inf(5)
		dim_line_num_@myarray ary_inf, i, i(4)
		gosub jump_(ary_inf(4), 2)

		; 文字列に対してインデックスの付与
		if (iflg == 1) & (vtype(2)) {
			in_val = inpt_buf           ; 足される方を元データに上書き
			in_val += "" + indexbuf_    ; インデックスの追加
			indexbuf_ += index          ; インデックスカウントアップ
		}
		else:if (iflg == 1)  :  in_val += index

		i(4)++
	loop
	return
//---------------------------------  配列代入  ---------------------------------//

*not_varset@myarray
	return

; 1次元配列 jump_(1, 2)
*setarray_1@myarray
	ary(i(0)) = in_val
	return

; 2次元配列 jump_(2, 2)
*setarray_2@myarray
	ary(i(0), i(1)) = in_val
	return

; 3次元配列 jump_(3, 2)
*setarray_3@myarray
	ary(i(0), i(1), i(2)) = in_val
	return

; 4次元配列 jump_(4, 2)
*setarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = in_val
	return


//##############################################################################
	; 多次元配列連続代入マクロ
	;
	; %1 : 代入先の配列変数
	; %2 : 代入したい値
	; %3 : indexフラグ(= 0, 0:OFF / 1:ON)
	; %4 : 増減値
	;
#define global setarray(%1,%2,%3=0,%4=1)\
	midlevar_@myarray=%2:\
	increase_@myarray=%4:\
	setarray_@myarray %1,midlevar_@myarray,%3,increase_@myarray





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   outarray (配列の値書き出し)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; hyouj : 配列変数の中身を受け取る文字列型変数
	; ary   : 配列変数
	; iflg  : 機能フラグ (= 0, 1:ラベルモード / 2:16進数大文字モード)
	;
#deffunc local outarray_ var hyouj, array ary, int iflg
	hoge = ""       ; ダミー

	ainfo_@myarray hyouj, ary, "", hoge, hoge, -1
	hoge = "\n", "\n\treturn\n"

	dim i, 7
	; ctrarray(動作制御命令)による離脱設定
	i(4)       = ctlarray_core_@myarray(0, i(4))
	ary_inf(5) = ctlarray_core_@myarray(1, ary_inf(5))

	; 書き出し
	repeat ary_inf(5)
		dim_line_num_@myarray ary_inf, i, i(4)
		gosub jump_(ary_inf(4), 3)
		i(4)++
	loop

	hyouj += "\n"      ; 次の配列変数表示のための改行
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varout@myarray
	return

; 1次元配列 jump_(1, 3)
*outarray_1@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0))}
	else:if vtype(1) {hyouj += "" + modlabgetc(ary(i.0)) + hoge.1}
	else             {hyouj += "" + ary(i.0) + hoge.iflg}
	return

; 2次元配列 jump_(2, 3)
*outarray_2@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1))}
	else:if vtype(1) {hyouj += "" + modlabgetc(ary(i.0, i.1)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1) + hoge.iflg}
	return

; 3次元配列 jump_(3, 3)
*outarray_3@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1, i.2))}
	else:if vtype(1) {hyouj += "" + modlabgetc(ary(i.0, i.1, i.2)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1, i.2) + hoge.iflg}
	return

; 4次元配列 jump_(4, 3)
*outarray_4@myarray
	if   (iflg == 2) {hyouj += strf(sfrmt(3, 5), ary(i.0, i.1, i.2, i.3))}
	else:if vtype(1) {hyouj += "" + modlabgetc(ary(i.0, i.1, i.2, i.3)) + hoge.1}
	else             {hyouj += "" + ary(i.0, i.1, i.2, i.3) + hoge.iflg}
	return


//##############################################################################
	; n次元配列の値のみを書き出すマクロ
	;
	; hyouj : 配列変数の中身を受け取る文字列型変数
	; ary   : 配列変数
	; iflg  : 機能フラグ (= 0, 1:ラベルモード / 2:16進数大文字モード)
	;
#define global outarray(%1,%2,%3=0) outarray_@myarray %1,%2,%3





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   cnvarray (配列へ変換)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; ary    : 変数名
	; in_val : 読み込む複数行文字列若しくは多次元配列変数
	; type   : 変換先の型を表す数値 (= 2, 2:文字列型 / 3:実数型 / 4:整数型)
	; d1,d2,d3,d4 : 変換後の各配列次元要素数
	;
#deffunc local cnvarray_ array ary, array in_val, int type, int d1, int d2, int d3, int d4
	sdim hogestr, 4096

	typ_info_@myarray in_val, vtype
	if (vtype(0) | vtype(6)) : goto jump_(0, 4)

	; 複数行文字列、多次元配列の判別
	if (length(in_val) > 1) {outarray_@myarray hogestr, in_val, 0} else {hogestr = in_val}
	notesel hogestr

	; 配列の各次元要素数
	dim ary_inf, 7
	if (d1 == 0) {ary_inf = length(in_val), length2(in_val), length3(in_val), length4(in_val)}
	else         {ary_inf = d1, d2, d3, d4}

	; 配列の初期化 * 型の変換
	if (type == 2) {sdim ary, notesize, ary_inf(0), ary_inf(1), ary_inf(2), ary_inf(3)}
	else           { dimtype ary, type, ary_inf(0), ary_inf(1), ary_inf(2), ary_inf(3)}

	; 次元の使用状況
	ary_inf(4) = (ary_inf(0) != 0) + (ary_inf(1) != 0) + (ary_inf(2) != 0) + (ary_inf(3) != 0)

	; 配列合計数
	ary_inf(5) = 1
	repeat ary_inf(4):   ary_inf(5) *= ary_inf(cnt)   :loop

	dim i, 7
	; 書き出し
	repeat ary_inf(5)
		dim_line_num_@myarray ary_inf, i, i(4)
		noteget hogeline, i(5)

		if      (type == 2) {hoge =    str(hogeline)}
		else:if (type == 3) {hoge = double(hogeline)}
		else:if (type == 4) {hoge =    int(hogeline)}

		gosub jump_(ary_inf(4), 4)         ; ラベルジャンプで分岐
		i(4)++ : i(5)++
	loop
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varcnv@myarray
	return

; 1次元配列 jump_(1, 4)
*cnvarray_1@myarray
	ary(i(0)) = hoge
	return

; 2次元配列 jump_(2, 4)
*cnvarray_2@myarray
	ary(i(0), i(1)) = hoge
	return

; 3次元配列 jump_(3, 4)
*cnvarray_3@myarray
	ary(i(0), i(1), i(2)) = hoge
	return

; 4次元配列 jump_(4, 4)
*cnvarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = hoge
	return


//##############################################################################
	; あらゆるものを多次元配列に変換する
	;
	; %1 : 変数名
	; %2 : 読み込む複数行文字列若しくは多次元配列
	; %3 : 変換先の型を表す数値 (= 2, 2:文字列型 / 3:実数型 / 4:整数型)
	; %4,%5,%6,%7 : 変換後の各次元要素
	;
#define global cnvarray(%1,%2,%3=2,%4=0,%5=0,%6=0,%7=0) cnvarray_@myarray %1,%2,%3,%4,%5,%6,%7





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   labarray (ラベル型量産)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; hyouj  : 書き出し先の複数行文字列型変数
	; ary    : 書き出す文字列型配列変数
	; in_val : 代入値またはそれを格納した変数
	; index  : 増減値
	;
#deffunc local labarray_ str vname, var hyouj, array ary, var in_val, var index, var coment
	inpt_buf = ""
	ainfo_@myarray hyouj, ary, vname, inpt_buf, coment, -2

	; インデックス付与のために一旦退避
	inpt_buf = in_val  :  indexbuf_ = index

	dim i, 7
	; ctrarray(動作制御命令)による離脱設定
	i(4)       = ctlarray_core_@myarray(0, i(4))
	ary_inf(5) = ctlarray_core_@myarray(1, ary_inf(5))

	repeat ary_inf(5)
		dim_line_num_@myarray ary_inf, i, i(4)
		gosub jump_(ary_inf(4), 5)

		; 文字列に対してインデックスの付与
		in_val = inpt_buf  :  in_val += "" + indexbuf_  :  indexbuf_ += index
		i(4)++
	loop

	hyouj += "\n"
	return
//---------------------------------  配列代入  ---------------------------------//

*not_varlab@myarray
	return

; 1次元配列 jump_(1, 5)
*labarray_1@myarray
	ary(i(0)) = in_val
	hyouj += strf("\t%s" + sfrmt(0, 1), hogestr, i(0), in_val)
	return

; 2次元配列 jump_(2, 5)
*labarray_2@myarray
	ary(i(0), i(1)) = in_val
	hyouj += strf("\t%s" + sfrmt(1, 1), hogestr, i(0), i(1), in_val)
	return

; 3次元配列 jump_(3, 5)
*labarray_3@myarray
	ary(i(0), i(1), i(2)) = in_val
	hyouj += strf("\t%s" + sfrmt(2, 1), hogestr, i(0), i(1), i(2), in_val)
	return

; 4次元配列 jump_(4, 5)
*labarray_4@myarray
	ary(i(0), i(1), i(2), i(3)) = in_val
	hyouj += strf("\t%s" + sfrmt(3, 1), hogestr, i(0), i(1), i(2), i(3), in_val)
	return


//##############################################################################
	; ラベル型多次元配列生成
	;
	; %1 : 書き出し先の複数行文字列型変数
	; %2 : 書き出す文字列型配列変数
	; %3 : 代入値またはそれを格納した変数
	; %4 : 増減値 (= 1)
	; %5 : コメント
	;
#define global labarray(%1,%2,%3,%4=1,%5="")\
	midlevar_@myarray=%3:\
	increase_@myarray=%4:\
	labcoment@myarray=%5:\
	labarray_@myarray "%2",%1,%2,midlevar_@myarray,increase_@myarray,labcoment@myarray





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   uniary (多次元配列を1次元配列として扱う)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	;
	; ary : 変数名
	; d1  : 配列のオフセット値 (1次元化要素数)
	;
#defcfunc uniary array ary, int dim_ofset
	dim j, 7
	linedim ary, j, dim_ofset
	gosub jump_(ary_inf(4), 6)
	return
//-------------------------------  配列書き出し  -------------------------------//
*not_varuni@myarray
	return

; junp_(1, 6)
*uniarray_1@myarray
	return ary(j.0)

; junp_(2, 6)
*uniarray_2@myarray
	return ary(j.0, j.1)

; junp_(3, 6)
*uniarray_3@myarray
	return ary(j.0, j.1, j.2)

; junp_(4, 6)
*uniarray_4@myarray
	return ary(j.0, j.1, j.2, j.3)





;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;                   calc_ary_ (配列の四則演算)
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	; ans_ary    : 計算結果を受け取る変数名 (ary1の変数型で初期化します)
	; ary1, ary2 : 変数名
	; calc_type  : 演算タイプ
	; error_stop : 0で除算エラーストップ (= 0, 0:停止しない / 1:停止する)
	;
#deffunc calc_ary array ans_ary, array ary1, array ary2, int calc_type, int error_stop

	; 型のチェック
	dim vtype1, 7 : typ_info_@myarray ary1, vtype1
	dim vtype2, 7 : typ_info_@myarray ary2, vtype2

	if      (vtype1(0) | vtype1(6) | vtype2(0) | vtype2(6)) {return -1} ; ラベル型、モジュール型、COMオブジェクト型は計算できない
	else:if (vtype1(2) | vtype2(2)) & (calc_type != 0)      {return -2} ; 文字列型の場合に加算以外を指定されたときも計算しない
	;___________________________________________________________________________

	; 詳細な情報の取得
	dim ary_inf1, 7 : dim_info_@myarray ary1, ary_inf1
	dim ary_inf2, 7 : dim_info_@myarray ary2, ary_inf2
	dim ans_inf, 7  ; ans_ary 用の配列情報 ans_ary はary1側の配列情報を使う
	foreach ary_inf1:   ans_inf(cnt) = ary_inf1(cnt)   :loop

	; 配列演算継続フラグ
	if (calc_add_flag == 0) {
		; ans_aryの型はary1側に合わせる
		if vtype1.2 {sdim ans_ary, 1024, ans_inf(0), ans_inf(1), ans_inf(2), ans_inf(3)}
		else        {dimtype ans_ary, vartype(ary1), ans_inf(0), ans_inf(1), ans_inf(2), ans_inf(3)}
	}

	; ans_ary用 : ary1用   :  ary2用
	dim i, 7  :  dim j, 7  :  dim k, 7
	dimtype ary1_, vartype(ary1)
	dimtype ary2_, vartype(ary2)

	; ctrarray(動作制御命令)による離脱設定
	i.4 = ctlarray_core_@myarray(0, i.4) :  ans_inf.5 = ctlarray_core_@myarray(1, ans_inf.5)
	j.4 = ctlarray_core_@myarray(0, j.4) : ary_inf1.5 = ctlarray_core_@myarray(1, ary_inf1.5)
	k.4 = ctlarray_core_@myarray(0, k.4) : ary_inf2.5 = ctlarray_core_@myarray(1, ary_inf2.5)

	repeat ans_inf(5)
		dim_line_num_@myarray ary_inf1, j, j(4) ; 右辺の左側 (〜される数)
		dim_line_num_@myarray ary_inf2, k, k(4) ; 右辺の右側 (〜する数)
		dim_line_num_@myarray ans_inf, i, i(4)  ; 左辺 (計算結果)

		i(5) = 0 : gosub jump_(ary_inf1(4), 7)  ; ary1の代入
		i(5) = 1 : gosub jump_(ary_inf2(4), 7)  ; ary2の代入
		i(5) = 2 : gosub jump_(ans_inf(4), 7)   ; 配列演算 (ans_aryの代入)

		i(4)++ : j(4)++ : k(4)++
	loop

	dim calc_add_flag ; 演算継続フラグを下ろす
	return
//-------------------------------  配列書き出し  -------------------------------//

*not_varcal@myarray
	return

; 1次元配列 jump_(1, 7)
*calc_ary_1@myarray
	if      (i.5 == 0) {ary1_ = ary1(j.0)}
	else:if (i.5 == 1) {ary2_ = ary2(k.0)}
	else:if (i.5 == 2) {ans_ary(i.0) = calc_var_ary_@myarray(ary1_, ary2_, calc_type, error_stop)}
	return

; 2次元配列 jump_(2, 7)
*calc_ary_2@myarray
	if      (i.5 == 0) {ary1_ = ary1(j.0, j.1)}
	else:if (i.5 == 1) {ary2_ = ary2(k.0, k.1)}
	else:if (i.5 == 2) {ans_ary(i.0, i.1) = calc_var_ary_@myarray(ary1_, ary2_, calc_type, error_stop)}
	return

; 3次元配列 jump_(3, 7)
*calc_ary_3@myarray
	if      (i.5 == 0) {ary1_ = ary1(j.0, j.1, j.2)}
	else:if (i.5 == 1) {ary2_ = ary2(k.0, k.1, k.2)}
	else:if (i.5 == 2) {ans_ary(i.0, i.1, i.2) = calc_var_ary_@myarray(ary1_, ary2_, calc_type, error_stop)}
	return

; 4次元配列 jump_(4, 7)
*calc_ary_4@myarray
	if      (i.5 == 0) {ary1_ = ary1(j.0, j.1, j.2, j.3)}
	else:if (i.5 == 1) {ary2_ = ary2(k.0, k.1, k.2, k.3)}
	else:if (i.5 == 2) {ans_ary(i.0, i.1, i.2, i.3) = calc_var_ary_@myarray(ary1_, ary2_, calc_type, error_stop)}
	return


//##############################################################################
	; 配列演算継続命令
	;
#deffunc calc_continue
	dim calc_add_flag : calc_add_flag = 1
	return


//##############################################################################
	; 配列演算関数 (分岐用)
	;
	; v1, v2     : ary1, ary2
	; calc_type  : 演算タイプ
	; error_stop : 0で除算エラー (= 0, 0:停止しない / 1:停止する)
	;
#defcfunc local calc_var_ary_ var v1, var v2, int calc_type, int error_stop, local calc_ch
	calc_ch = ((calc_type == 3) | (calc_type == 4)) & (v2 == 0) & (error_stop == 0)

	if      calc_ch & (vartype(v1) == 4) {return -2147483648}
	else:if calc_ch & (vartype(v1) == 3) {return -214748364.8}
	else:if (calc_type == 0) {return (v1 + v2)}    ; 加算
	else:if (calc_type == 1) {return (v1 - v2)}    ; 減算
	else:if (calc_type == 2) {return (v1 * v2)}    ; 乗算
	else:if (calc_type == 3) {return (v1 / v2)}    ; 除算
	else:if (calc_type == 4) {return (v1 \ v2)}    ; 剰余
	else:if (calc_type == 5) {return (v1 + v1 * v2)}        ; 割増 (実数指定)
	else:if (calc_type == 6) {return (v1 - v1 * v2)}        ; 割引 (実数指定)
	else:if (calc_type == 7) {return (v1 + v1 * v2 * 0.01)} ; 割増(%)
	else:if (calc_type == 8) {return (v1 - v1 * v2 * 0.01)} ; 割引(%)

	;
	; ↑こちらにどんどん計算式を追加することでカスタムすることができます。

#global // myarray

	_myarray_init_@myarray    ; モジュール内の管理用変数の初期化です

#endif //__myarray__